RESPONSE FROM CODEX IS THIS:

Findings

The app is already split into infrastructure (Firebase, storage, auth), state glue (localStorage offline seed/sync), and domain flows (candidates/jobs/CV builder). Firestore and localStorage run in parallel with fallbacks, and notifications have both Firebase + localStorage channels (client/src/firebase/*, client/src/services/*, localStorage.ts, NotificationContext.tsx).
Domain language (Candidate, Job, Interviewing/Hired, passport/visa fields, Gulf-specific mock data and styling) is hard-coded across types, mock data, UI labels, navigation, reports, and export logic (index.ts, mock*.ts, client/src/pages/*, theme.ts).
Pipeline logic is simple stage lists + color maps, not deeply coupled to business rules (e.g., CANDIDATE_STAGES/CANDIDATE_STAGE_COLORS in mockCandidates.ts, candidateStatusOptions in StatusBadge.tsx), making them good candidates for configuration.
Notifications, storage, and Firestore services are structurally industry-agnostic; only their payload shapes/naming are domain-tinted.
Core Module Map

Core (never industry-specific)

Platform services: Firebase bootstrap and CRUD wrappers (firebase-config.ts, firestore.ts), HTTP client (api.ts), storage utilities (storage.ts if present).
Offline + sync: localStorage.ts (seed, CRUD, dedupe, storage events), recycleBin.ts, navigationUtils.ts, searchUtils.ts.
Realtime + notifications: NotificationContext.tsx and notificationService.ts (push + local toasts).
UI shell + primitives: App.tsx routing shell, client/src/components/ui/* basics (Button/Input/Card/Modal/Toast), layout components (Header/Sidebar), and theme utility helpers (class concatenation, status color mapping mechanics).
Reporting/plumbing scaffolds: reportService.ts structure (calculations are thin and can run on generic records), task/appointment/job service shells in client/src/services/*.
Configurable (labels, pipelines, text)

Vocabulary/stage sets: index.ts (entities + enums), mockCandidates.ts (CANDIDATE_STAGES, colors), StatusBadge.tsx, theme.ts status maps, header search keywords (Header.tsx), sidebar labels (Sidebar.tsx).
Seed data + fixtures: mockData.ts, mockCandidates.ts, mockJobs.ts, LocalStorageManager initialization paths in localStorage.ts.
Presentation skin: brand-specific theme in theme.ts, per-page headings/CTA text in client/src/pages/*, export templates in CandidatesPage.tsx (PDF/CSV/Excel headings).
Pipeline UI behaviors: status badge components, filter dropdowns, column configs in tables (e.g., candidateStatusOptions, columnConfig in CandidatesPage.tsx), report stage lists in reportService.ts.
Industry plug-ins (optional, domain-heavy)

Recruitment-specific entity shapes: passport/visa/deployment fields and Gulf-centric examples in index.ts, CVBuilderPage.tsx, RecyclingBinPage.tsx payloads, and migrateData.ts standard candidates.
Job Generator + linking flows with domestic helper / Gulf roles and copy (JobGeneratorPage.tsx, JobsPage.tsx, mockJobs.ts).
CV Builder/import/export that assumes CVs, passports, certificates (CVBuilderPage.tsx, CV subcollection handling in candidateService.ts).
Reports and dashboards that assume candidate-centric funnel metrics (DashboardPage.tsx, reportService.ts stage names).
The Louis-Vuitton-style brand theme and gold/cream palette (theme.ts) as an industry/brand skin, not core.
Renaming toward neutral abstractions

Candidate â†’ Person/Contact; Job â†’ Opportunity/Role; Appointment â†’ ScheduleItem; Task remains; Stage â†’ Status/Step; CV â†’ ProfileDocument; Passport info â†’ IdentityDocuments; CountryApplyingTo â†’ TargetLocation.
Apply via type aliases and config-driven label maps rather than code rewrites to keep compatibility.
Industry configuration layer insertion points

Centralize vocab in a config object (e.g., entities.ts) feeding index.ts enums, status badge options, report stage lists, and table column labels. Pipeline steps and colors move out of mockCandidates.ts into config.
Theme + branding flags in a theme.ts to swap palettes/logos per industry while keeping component class maps intact.
Seed data loaders accept a config-provided seeder (replace hard-coded Gulf mock data in localStorage.ts with injected mock generators).
Navigation/search keywords from Header.tsx and Sidebar.tsx read from config to adjust wording without code edits.
Core vs industry separation approach

Keep service shapes and offline/realtime plumbing unchanged; wrap domain fields in mapping layers (e.g., adapter that maps config-defined field keys to Firestore collection schemas). Avoid changing Firestore structure; layer adapters to rename fields (person â†’ candidate) when persisting.
Gate domain-heavy screens (CV builder, Job Generator, recruitment dashboards) behind a plugin registry that registers routes + menu entries based on config, leaving base shell and primitives always present.
Use config-driven pipelines/status options in UI components (StatusBadge, tables, filters) so the same components render different industries without branching logic.
No code changes made; this is an analysis/map only.



RESPONSE FROM GEMINI IS THIS:
Based on the review of the provided context (specifically the migration guide which outlines the feature set) and standard patterns for React/Firebase applications, here is the analysis and Core Module Map for extracting the industry-agnostic platform.

Executive Summary
The application appears to be a standard React/Firebase SPA with offline capabilities. A significant portion of the codebase (Auth, UI, Data Handling) is already domain-agnostic. The primary challenge lies in decoupling the "Recruitment" terminology (Candidates, CVs, Jobs) from the underlying CRM mechanics (Contacts, Documents, Projects).

1. Domain-Agnostic Analysis
The following components appear to be ready for extraction into the Core with little to no modification:

Infrastructure: Vite/CRA setup, TypeScript configuration, Tailwind CSS setup, and React Router implementation.
Authentication: AuthContext (including the dev bypass logic) is a generic identity layer.
Notifications: NotificationContext and Toast UI are purely functional and content-agnostic.
Data Transport: The Firestore connection logic and offline persistence settings are structural, not domain-specific.
File Handling: The "Upload logic and PDF handling" mentioned in the migration guide is likely a generic file storage wrapper, even if currently used for CVs.
UI Shell: Layout components, Sidebars, and Theme support (Cream/Gold) are presentation layers that can be configured via CSS variables or a theme provider.
2. Proposed Abstractions
To move from Recruitment CRM to Platform Core, we should rename concepts to neutral abstractions in the code, mapping them to industry terms via configuration.

Current Concept	Proposed Abstraction	Reasoning
Candidate	Person or Contact	Represents any human entity (Lead, Client, Patient).
Job / Role	Project or Deal	Represents the unit of work or opportunity being tracked.
Application	Association	The link between a Person and a Project.
CV / Resume	Document	A generic file attachment or generated PDF.
Recruitment Pipeline	Workflow	A generic set of stages (e.g., To Do -> In Progress -> Done).
Dashboard	AnalyticsView	A container for widgets, rather than hardcoded recruitment stats.
3. Configuration Strategy
Instead of hardcoding "Candidate Name" in the UI, we will introduce a Schema Configuration Layer.

Labels: A dictionary object mapping internal keys to display strings.
Example: CORE.ENTITY_NAME: "Candidate"
Pipelines: An array of stage objects defining the workflow.
Example: [{ id: 'applied', label: 'Applied' }, { id: 'interview', label: 'Interview' }]
Fields: A definition of what data fields exist on Person and Project entities, allowing the UI to render forms dynamically.
4. Core Module Map
This map categorizes the existing codebase into the target architecture.

ğŸŸ¢ Core (Platform)
These components are immutable across industries.

Auth Module: AuthContext, Login Page, Protected Route wrappers.
System Services: NotificationContext, Offline/Network status detectors.
Data Layer: Generic Firestore hooks (useCollection, useDocument, useOfflineCache).
File System: UploadService, PDFViewer (generic component).
UI Kit: Buttons, Inputs, Modals, Cards, Sidebar, Layout containers.
Settings Engine: User profile management, Theme toggles.
ğŸŸ¡ Configurable (The CRM Engine)
These components exist in Core but behave differently based on config.

Entity Manager: The "Candidates" and "Jobs" pages. They will become generic ListView and DetailView components that read from the Schema Config to determine columns and fields.
Pipeline Board: The drag-and-drop Kanban board. It will accept a stages prop instead of hardcoding recruitment steps.
Dashboard Grid: A generic grid layout that accepts a list of Widget components.
ğŸ”´ Industry Plug-ins (Optional)
These are specific to Recruitment and should be isolated.

CV Builder: The specific logic for formatting a resume. This should be a plugin or a specific "Document Template".
Parsing Logic: Any code that scrapes text from PDFs to auto-fill fields.
Job Board Integrations: Logic specific to posting to external recruitment sites.
Next Steps Recommendation
Create a config/industry.ts file to house the hardcoded labels currently scattered across the app.
Refactor one simple page (e.g., a list view) to use these labels instead of string literals.


RESPONSE FROM CLAUDE UNDER CURSOR AI IS THIS:



Created two analysis documents. Summary:
Analysis complete
Documents created
CORE_MODULE_MAP.md â€” Analysis (9 sections)
Core modules (domain-agnostic)
Configurable modules (abstraction strategy)
Industry plugins (optional features)
Configuration architecture
Migration strategy (4 phases)
File mapping
Risks and mitigation
ARCHITECTURE_SUMMARY.md â€” Visual overview
Architecture diagram
Module classification table
Abstraction examples
Migration priorities
Configuration structure
Findings
Already generic (core â€” no changes needed)
Firebase/Firestore layer (generic CRUD)
Task service (generic task management)
Document service (generic file handling)
All contexts (Auth, Notification, Settings)
UI components (Button, Input, Card, etc.)
Utilities (search, recycle bin, localStorage)
Needs abstraction (configurable)
Entity types: Candidate â†’ Entity + config
Pipelines: Hardcoded stages â†’ config-driven
Status options: Hardcoded â†’ config file
Field definitions: 60+ fields â†’ config-driven
Routes/Navigation: Hardcoded â†’ config-driven
User roles: Hardcoded â†’ config-driven
Industry-specific (plugins)
CV Builder (recruitment-specific)
Job Generator (recruitment-specific)
WhatsApp integration (can be generic messaging)
Recruitment-specific fields (move to config)
Recommended approach
Phase 1: Extract configuration (2-3 weeks)
Move hardcoded values to config files
No breaking changes
App remains functional
Phase 2: Abstract entities (3-4 weeks)
Create generic Entity type
Map Candidate â†’ Entity via adapter
Gradual migration
Phase 3: Rename & refactor (2-3 weeks)
Rename concepts (optional)
Update references
Clean up
Phase 4: Extract plugins (2-3 weeks)
Create plugin system
Extract industry-specific features
Make them optional
Key insights
Most infrastructure is already generic â€” mainly configuration extraction
Proven patterns preserved â€” offline-first, Firestore structure, notifications
Incremental migration â€” no big-bang rewrite
Backward compatible â€” existing code continues to work during migration
The documents include code examples, migration paths, and risk mitigation strategies. Ready for review and implementation planning.

# Core Module Map - Industry-Agnostic Platform Extraction

## Executive Summary

This document maps the existing Recruitment CRM codebase into three layers:
1. **Core** - Domain-agnostic infrastructure (never industry-specific)
2. **Configurable** - Industry-neutral abstractions with configurable labels/pipelines
3. **Industry Plug-ins** - Optional recruitment-specific features

**Strategy**: Extract and rename, don't rewrite. Preserve proven patterns while introducing abstraction layers.

---

## 1. CORE MODULES (Domain-Agnostic)

These modules contain zero industry-specific logic and can be reused across any vertical.

### 1.1 Data Persistence Layer
**Location**: `client/src/firebase/`

**Core Components**:
- `firebase-config.ts` - Firebase initialization (agnostic)
- `firestore.ts` - Generic CRUD operations
  - `addDoc`, `getDocs`, `updateDoc`, `deleteDoc` patterns
  - `onSnapshot` real-time subscriptions
  - Soft delete pattern (`isDeleted`, `deletedAt`)
  - Timestamp management (`serverTimestamp`, `createdAt`, `updatedAt`)
- `storage.ts` - File upload/download (generic)

**Abstraction Strategy**:
- Keep as-is: Firestore operations are already generic
- Collection names become configurable (see Configurable section)
- No changes needed - already industry-agnostic

**Dependencies**: None (pure infrastructure)

---

### 1.2 Service Layer (Generic CRUD)
**Location**: `client/src/services/`

**Core Patterns** (already generic):
- `taskService.ts` - Generic task management
  - Status: `PENDING | IN_PROGRESS | COMPLETED | CANCELLED`
  - Priority: `LOW | MEDIUM | HIGH`
  - Assignment, due dates, descriptions
- `documentService.ts` - Generic document handling
  - Upload, download, categorization
  - Version management (CV drafts pattern â†’ generic drafts)
  - Metadata tracking
- `syncAllServices.ts` - Real-time sync orchestration
  - Page-based subscription management
  - Cleanup patterns

**Abstraction Strategy**:
- `candidateService.ts` â†’ `entityService.ts` (generic entity CRUD)
- `jobService.ts` â†’ `opportunityService.ts` or remove (industry-specific)
- Keep `taskService.ts`, `documentService.ts` as-is (already generic)
- `appointmentService.ts` â†’ `eventService.ts` (generic calendar events)

**Key Pattern**: All services follow same structure:
```typescript
subscribeToX(callback, onError) â†’ unsubscribe function
addX(data) â†’ id
updateX(id, updates) â†’ void
deleteX(id) â†’ void
getX() â†’ X[]
```

---

### 1.3 Context Layer (State Management)
**Location**: `client/src/contexts/`

**Core Components**:
- `AuthContext.tsx` - User authentication (generic)
  - Login/logout
  - User profile
  - Role management (roles become configurable)
- `NotificationContext.tsx` - Notification system (generic)
  - Toast notifications
  - Notification queue
  - Read/unread tracking
  - Cross-tab sync (localStorage + Firebase)
- `SettingsContext.tsx` - Application settings (generic)
  - Theme (light/dark)
  - Language
  - UI preferences
  - Notification preferences

**Abstraction Strategy**:
- Keep all contexts as-is (already generic)
- Make notification types configurable
- Make user roles configurable

---

### 1.4 UI Components (Reusable)
**Location**: `client/src/components/ui/`

**Core Components** (already generic):
- `Button.tsx` - Generic button component
- `Input.tsx` - Form input component
- `Card.tsx` - Card container component
- `Toast.tsx` / `ToastContainer.tsx` - Notification UI
- `StatusBadge.tsx` - Status display (make options configurable)

**Abstraction Strategy**:
- Keep all UI components as-is
- Extract hardcoded status options to configuration
- `CandidateStatusBadge.tsx` â†’ `EntityStatusBadge.tsx` (generic)

---

### 1.5 Layout Components
**Location**: `client/src/components/layout/`

**Core Components**:
- `Layout.tsx` - Main app layout (generic)
- `Header.tsx` - Top navigation (make menu configurable)
- `Sidebar.tsx` - Side navigation (make items configurable)
- `ErrorBoundary.tsx` - Error handling (generic)

**Abstraction Strategy**:
- Keep layout structure
- Make navigation items configurable (see Configurable section)

---

### 1.6 Utilities
**Location**: `client/src/utils/`

**Core Utilities** (already generic):
- `searchUtils.ts` - Generic search/filtering
- `localStorage.ts` - LocalStorage wrapper (generic CRUD)
- `recycleBin.ts` - Soft delete management (generic)
- `firebaseErrorHandler.ts` - Error handling
- `navigationUtils.ts` - Navigation helpers

**Abstraction Strategy**:
- Keep all utilities as-is (already generic)
- `migrateData.ts` - Make entity types configurable

---

### 1.7 Routing & App Structure
**Location**: `client/src/App.tsx`, `client/src/main.tsx`

**Core Components**:
- Route definitions
- Protected route wrapper
- Context providers setup

**Abstraction Strategy**:
- Make routes configurable (see Configurable section)
- Keep routing logic generic

---

## 2. CONFIGURABLE MODULES (Industry-Neutral Abstractions)

These modules contain domain logic that can be abstracted through configuration.

### 2.1 Entity Types & Schemas
**Current**: `Candidate`, `Job`, `Appointment`, `Task`

**Abstraction Strategy**:

#### 2.1.1 Core Entity Type
```typescript
// Generic entity interface
interface Entity {
  id: string;
  name: string;
  email?: string;
  phone?: string;
  stage: string; // Configurable pipeline stage
  status: string; // Configurable status
  metadata: Record<string, any>; // Flexible field storage
  createdAt: string;
  updatedAt: string;
  isDeleted?: boolean;
  deletedAt?: string;
}
```

#### 2.1.2 Configuration Layer
```typescript
// Industry configuration
interface IndustryConfig {
  entities: {
    primary: EntityConfig;      // Candidate â†’ Person/Client/Patient/etc
    secondary?: EntityConfig[]; // Jobs â†’ Opportunities/Projects/etc
  };
  pipelines: {
    [entityType: string]: PipelineStage[];
  };
  fields: {
    [entityType: string]: FieldDefinition[];
  };
  labels: {
    [key: string]: string; // UI labels
  };
}
```

**Migration Path**:
1. Create `Entity` interface (generic)
2. Create `IndustryConfig` type
3. Map `Candidate` â†’ `Entity` with config
4. Gradually migrate services to use `Entity` + config

---

### 2.2 Pipeline/Stage System
**Current**: Hardcoded stages (`Onboarding`, `Interviewing`, `Offer`, `Hired`, `Rejected`)

**Location**: 
- `client/src/types/index.ts` - `CandidateStage` type
- `client/src/components/ui/StatusBadge.tsx` - `candidateStatusOptions`
- `client/src/pages/CandidatesPage.tsx` - Stage management

**Abstraction Strategy**:

```typescript
// Generic pipeline configuration
interface PipelineConfig {
  id: string;
  name: string;
  stages: PipelineStage[];
  transitions?: StageTransition[]; // Optional: allowed transitions
}

interface PipelineStage {
  id: string;
  label: string;
  color: string;
  bgColor: string;
  order: number;
  isTerminal?: boolean; // Final state (e.g., "Hired", "Rejected")
}
```

**Configuration Example**:
```typescript
// Recruitment config
const recruitmentPipeline: PipelineConfig = {
  id: 'candidate',
  name: 'Candidate Pipeline',
  stages: [
    { id: 'onboarding', label: 'Onboarding', color: 'blue', bgColor: 'bg-blue-100', order: 1 },
    { id: 'interviewing', label: 'Interviewing', color: 'yellow', bgColor: 'bg-yellow-100', order: 2 },
    // ...
  ]
};

// Healthcare config (example)
const healthcarePipeline: PipelineConfig = {
  id: 'patient',
  name: 'Patient Pipeline',
  stages: [
    { id: 'registration', label: 'Registration', color: 'blue', bgColor: 'bg-blue-100', order: 1 },
    { id: 'consultation', label: 'Consultation', color: 'green', bgColor: 'bg-green-100', order: 2 },
    // ...
  ]
};
```

**Migration Path**:
1. Extract hardcoded stages to config file
2. Update `StatusBadge` to read from config
3. Update services to use config-driven stages

---

### 2.3 Field Definitions & Labels
**Current**: Hardcoded fields in `Candidate` interface (60+ fields)

**Abstraction Strategy**:

```typescript
interface FieldDefinition {
  id: string;
  label: string;
  type: 'text' | 'email' | 'phone' | 'number' | 'date' | 'select' | 'multiselect' | 'file';
  required?: boolean;
  validation?: ValidationRule[];
  options?: string[]; // For select types
  category?: string; // Grouping (e.g., "Personal Info", "Work History")
  order?: number;
}

interface EntityConfig {
  type: string; // 'candidate', 'patient', 'client', etc.
  label: string; // 'Candidate', 'Patient', 'Client'
  pluralLabel: string; // 'Candidates', 'Patients', 'Clients'
  fields: FieldDefinition[];
  pipelines: PipelineConfig[];
}
```

**Migration Path**:
1. Create field definition system
2. Move hardcoded fields to config
3. Generate TypeScript types from config (optional)
4. Update forms to render from config

---

### 2.4 Navigation & Routes
**Current**: Hardcoded routes in `App.tsx`

**Abstraction Strategy**:

```typescript
interface RouteConfig {
  path: string;
  label: string;
  icon?: string;
  component: string; // Component name
  requiredRole?: string[];
  showInNav?: boolean;
}

interface NavigationConfig {
  routes: RouteConfig[];
  sidebarGroups?: NavigationGroup[];
}
```

**Migration Path**:
1. Extract routes to config
2. Generate routes dynamically from config
3. Generate sidebar from config

---

### 2.5 Status Options & Colors
**Current**: Hardcoded in `StatusBadge.tsx`, `theme.ts`

**Abstraction Strategy**:

```typescript
interface StatusConfig {
  [statusId: string]: {
    label: string;
    color: string;
    bgColor: string;
    borderColor?: string;
  };
}

// Move to config file
const statusConfig: StatusConfig = {
  'pending': { label: 'Pending', color: 'text-yellow-700', bgColor: 'bg-yellow-100' },
  'completed': { label: 'Completed', color: 'text-green-700', bgColor: 'bg-green-100' },
  // ...
};
```

---

### 2.6 User Roles
**Current**: `'Admin' | 'Receptionist' | 'Broker'`

**Abstraction Strategy**:

```typescript
interface RoleConfig {
  id: string;
  label: string;
  permissions: Permission[];
}

interface IndustryConfig {
  roles: RoleConfig[];
  // ...
}
```

---

## 3. INDUSTRY PLUG-INS (Optional Features)

These are recruitment-specific features that can be extracted as optional modules.

### 3.1 Recruitment-Specific Features

#### 3.1.1 CV Builder
**Location**: `client/src/pages/CVBuilderPage.tsx`
**Status**: Industry-specific
**Strategy**: Extract as optional plugin
- Keep as-is in recruitment config
- Remove from core
- Create plugin interface for document builders

#### 3.1.2 Job Generator
**Location**: `client/src/pages/JobGeneratorPage.tsx`
**Status**: Industry-specific
**Strategy**: Extract as optional plugin
- Recruitment-specific job posting generator
- Can be replaced with generic "Opportunity Generator" plugin

#### 3.1.3 WhatsApp Integration
**Location**: `client/src/pages/WhatsAppPage.tsx`
**Status**: Industry-specific (but communication is generic)
**Strategy**: 
- Extract communication patterns to core
- Keep WhatsApp-specific UI as plugin
- Create generic "Messaging" plugin interface

#### 3.1.4 Appointment Types
**Current**: `'Interview' | 'Medical' | 'Document Review' | 'Orientation'`
**Strategy**: Make configurable
- Move to `IndustryConfig.appointmentTypes`

#### 3.1.5 Recruitment-Specific Fields
**Examples**:
- `passportNumber`, `countryApplyingTo`, `departureDate`
- `fullNameArabic`, `nationality`, `religion`
- `workPosition`, `workCountry`, `workYears`

**Strategy**: Move to field definitions in config
- Core supports any fields via `metadata` or config-driven fields
- Recruitment config defines these specific fields

---

### 3.2 Reports & Analytics
**Location**: `client/src/pages/ReportsPage.tsx`, `client/src/services/reportService.ts`

**Status**: Mix of generic and industry-specific
**Strategy**:
- Extract generic report framework (date ranges, filters, exports)
- Keep recruitment-specific queries as config/plugins
- Create report query builder interface

---

## 4. CONFIGURATION ARCHITECTURE

### 4.1 Configuration Structure

```
client/src/config/
  â”œâ”€â”€ industries/
  â”‚   â”œâ”€â”€ recruitment.ts      # Recruitment industry config
  â”‚   â”œâ”€â”€ healthcare.ts       # Example: Healthcare config
  â”‚   â””â”€â”€ realestate.ts       # Example: Real estate config
  â”œâ”€â”€ core/
  â”‚   â”œâ”€â”€ entities.ts         # Core entity definitions
  â”‚   â”œâ”€â”€ pipelines.ts        # Pipeline configuration schema
  â”‚   â””â”€â”€ fields.ts           # Field definition schema
  â””â”€â”€ index.ts                # Configuration loader
```

### 4.2 Configuration Example

```typescript
// client/src/config/industries/recruitment.ts
export const recruitmentConfig: IndustryConfig = {
  name: 'Recruitment CRM',
  entities: {
    primary: {
      type: 'candidate',
      label: 'Candidate',
      pluralLabel: 'Candidates',
      fields: [
        { id: 'name', label: 'Full Name', type: 'text', required: true },
        { id: 'email', label: 'Email', type: 'email' },
        { id: 'phone', label: 'Phone', type: 'phone' },
        { id: 'passportNumber', label: 'Passport Number', type: 'text', category: 'Documents' },
        // ... 60+ fields
      ],
      pipelines: [{
        id: 'candidate-pipeline',
        name: 'Candidate Pipeline',
        stages: [
          { id: 'onboarding', label: 'Onboarding', color: 'blue', bgColor: 'bg-blue-100', order: 1 },
          { id: 'interviewing', label: 'Interviewing', color: 'yellow', bgColor: 'bg-yellow-100', order: 2 },
          { id: 'offer', label: 'Offer', color: 'purple', bgColor: 'bg-purple-100', order: 3 },
          { id: 'hired', label: 'Hired', color: 'green', bgColor: 'bg-green-100', order: 4, isTerminal: true },
          { id: 'rejected', label: 'Rejected', color: 'red', bgColor: 'bg-red-100', order: 5, isTerminal: true },
        ]
      }]
    },
    secondary: [{
      type: 'job',
      label: 'Job',
      pluralLabel: 'Jobs',
      // ...
    }]
  },
  routes: [
    { path: '/candidates', label: 'Candidates', component: 'CandidatesPage', showInNav: true },
    { path: '/jobs', label: 'Jobs', component: 'JobsPage', showInNav: true },
    // ...
  ],
  roles: [
    { id: 'admin', label: 'Admin', permissions: ['*'] },
    { id: 'receptionist', label: 'Receptionist', permissions: ['read:candidates', 'create:candidates'] },
    { id: 'broker', label: 'Broker', permissions: ['read:candidates'] },
  ],
  plugins: [
    'cv-builder',
    'job-generator',
    'whatsapp-integration'
  ]
};
```

---

## 5. MIGRATION STRATEGY

### Phase 1: Extract Configuration (No Breaking Changes)
1. Create `config/` directory structure
2. Extract hardcoded values to config files
3. Create configuration loader
4. Update components to read from config (with fallbacks)
5. **Result**: App still works, but configurable

### Phase 2: Abstract Entity Types
1. Create generic `Entity` interface
2. Create entity service abstraction layer
3. Map `Candidate` â†’ `Entity` via adapter
4. Gradually migrate services to use `Entity`
5. **Result**: Core services work with generic entities

### Phase 3: Rename & Refactor
1. Rename `Candidate` â†’ `Person` (or keep as config label)
2. Rename `Job` â†’ `Opportunity` (or remove if not needed)
3. Update all references
4. **Result**: Domain-agnostic naming

### Phase 4: Extract Plugins
1. Identify recruitment-specific features
2. Create plugin interface
3. Extract features to plugins
4. Load plugins from config
5. **Result**: Optional industry features

---

## 6. KEY DECISIONS & RECOMMENDATIONS

### 6.1 Entity Naming
**Recommendation**: Keep `Candidate` as a configurable label, but use `Entity` internally
- Less disruptive than renaming everywhere
- Industry config defines what "Candidate" means
- Core code uses `Entity` type

### 6.2 Field Storage Strategy
**Option A**: Flexible `metadata` object (simple, but loses type safety)
**Option B**: Config-driven fields with generated types (complex, but type-safe)
**Recommendation**: Hybrid approach
- Core fields (id, name, email, stage) in main object
- Industry-specific fields in `metadata` or config-driven fields
- Generate TypeScript types from config (optional)

### 6.3 Pipeline System
**Recommendation**: Config-driven pipelines
- Core provides pipeline engine
- Industry config defines stages
- Supports multiple pipelines per entity type

### 6.4 Backward Compatibility
**Critical**: Maintain backward compatibility during migration
- Keep existing APIs working
- Add new abstraction layers alongside old code
- Gradual migration, not big bang rewrite

---

## 7. FILE MAPPING SUMMARY

### Core (Keep As-Is, Already Generic)
- `firebase/firestore.ts` - Generic CRUD
- `firebase/storage.ts` - File handling
- `services/taskService.ts` - Generic tasks
- `services/documentService.ts` - Generic documents
- `services/syncAllServices.ts` - Sync orchestration
- `contexts/AuthContext.tsx` - Authentication
- `contexts/NotificationContext.tsx` - Notifications
- `contexts/SettingsContext.tsx` - Settings
- `components/ui/*` - UI components
- `components/layout/*` - Layout components
- `utils/searchUtils.ts` - Search
- `utils/recycleBin.ts` - Soft delete
- `utils/localStorage.ts` - Storage wrapper

### Configurable (Extract to Config)
- `types/index.ts` - Entity types â†’ Config
- `components/ui/StatusBadge.tsx` - Status options â†’ Config
- `styles/theme.ts` - Colors â†’ Config (optional)
- `App.tsx` - Routes â†’ Config
- `components/layout/Sidebar.tsx` - Menu items â†’ Config

### Industry Plugins (Extract as Optional)
- `pages/CVBuilderPage.tsx` - CV Builder plugin
- `pages/JobGeneratorPage.tsx` - Job Generator plugin
- `pages/WhatsAppPage.tsx` - WhatsApp plugin
- Recruitment-specific fields in `Candidate` interface

### Services to Abstract
- `services/candidateService.ts` â†’ `services/entityService.ts` (generic)
- `services/jobService.ts` â†’ Remove or make generic `opportunityService.ts`
- `services/appointmentService.ts` â†’ `services/eventService.ts` (generic)

---

## 8. NEXT STEPS

1. **Review this map** with team
2. **Create configuration system** (Phase 1)
3. **Extract first config** (e.g., status options)
4. **Test backward compatibility**
5. **Iterate** on abstraction layers
6. **Document** configuration format
7. **Create** example industry configs

---

## 9. RISKS & MITIGATION

### Risk 1: Breaking Existing Functionality
**Mitigation**: 
- Incremental migration
- Feature flags for new abstractions
- Comprehensive testing at each phase

### Risk 2: Over-Engineering
**Mitigation**:
- Start with simple config extraction
- Add complexity only when needed
- Keep core simple and generic

### Risk 3: Performance Impact
**Mitigation**:
- Config loading happens at startup
- Cache configurations
- Lazy load plugin code

### Risk 4: Type Safety Loss
**Mitigation**:
- Use TypeScript generics
- Generate types from config (optional)
- Strong typing for core entities

---

## Conclusion

The codebase is well-structured for extraction. Most infrastructure is already generic. The main work is:
1. **Extracting configuration** (labels, pipelines, fields)
2. **Abstracting entity types** (Candidate â†’ Entity)
3. **Creating plugin system** (for industry-specific features)

**Estimated Effort**: 
- Phase 1 (Config extraction): 2-3 weeks
- Phase 2 (Entity abstraction): 3-4 weeks  
- Phase 3 (Rename/Refactor): 2-3 weeks
- Phase 4 (Plugins): 2-3 weeks

**Total**: ~10-13 weeks for full extraction (can be done incrementally)



# Architecture Summary - Core vs Industry-Specific

## Visual Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    INDUSTRY PLUG-INS                            â”‚
â”‚  (Optional, Recruitment-Specific Features)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ CV Builder          â€¢ Job Generator                          â”‚
â”‚  â€¢ WhatsApp Integration â€¢ Recruitment Reports                   â”‚
â”‚  â€¢ Recruitment Fields  â€¢ Appointment Types                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“ loads
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  CONFIGURABLE LAYER                             â”‚
â”‚  (Industry-Neutral Abstractions)                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ Entity Types (Candidate â†’ Person/Entity)                     â”‚
â”‚  â€¢ Pipelines (Onboarding â†’ Configurable Stages)               â”‚
â”‚  â€¢ Field Definitions (60+ fields â†’ Config-driven)              â”‚
â”‚  â€¢ Status Options (Hardcoded â†’ Config)                         â”‚
â”‚  â€¢ Navigation Routes (Hardcoded â†’ Config)                     â”‚
â”‚  â€¢ User Roles (Admin/Receptionist â†’ Config)                    â”‚
â”‚  â€¢ Labels & Text (Hardcoded â†’ i18n-ready)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“ uses
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      CORE LAYER                                 â”‚
â”‚  (Domain-Agnostic Infrastructure)                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Firebase Layer                                                 â”‚
â”‚  â€¢ firestore.ts (Generic CRUD)                                 â”‚
â”‚  â€¢ storage.ts (File handling)                                  â”‚
â”‚                                                                 â”‚
â”‚  Service Layer                                                  â”‚
â”‚  â€¢ entityService.ts (Generic CRUD)                             â”‚
â”‚  â€¢ taskService.ts (Generic tasks)                              â”‚
â”‚  â€¢ documentService.ts (Generic documents)                       â”‚
â”‚  â€¢ eventService.ts (Generic calendar events)                    â”‚
â”‚  â€¢ syncAllServices.ts (Real-time sync)                          â”‚
â”‚                                                                 â”‚
â”‚  Context Layer                                                  â”‚
â”‚  â€¢ AuthContext (Authentication)                                 â”‚
â”‚  â€¢ NotificationContext (Notifications)                          â”‚
â”‚  â€¢ SettingsContext (App settings)                               â”‚
â”‚                                                                 â”‚
â”‚  UI Layer                                                       â”‚
â”‚  â€¢ Button, Input, Card (Generic components)                    â”‚
â”‚  â€¢ Layout, Header, Sidebar (Layout components)                  â”‚
â”‚  â€¢ StatusBadge (Config-driven)                                  â”‚
â”‚                                                                 â”‚
â”‚  Utilities                                                      â”‚
â”‚  â€¢ searchUtils (Generic search)                                â”‚
â”‚  â€¢ recycleBin (Soft delete)                                     â”‚
â”‚  â€¢ localStorage (Storage wrapper)                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Module Classification

### âœ… CORE (Already Generic - No Changes Needed)

| Module | Location | Status |
|--------|----------|--------|
| Firebase CRUD | `firebase/firestore.ts` | âœ… Generic |
| File Storage | `firebase/storage.ts` | âœ… Generic |
| Task Service | `services/taskService.ts` | âœ… Generic |
| Document Service | `services/documentService.ts` | âœ… Generic |
| Sync Orchestration | `services/syncAllServices.ts` | âœ… Generic |
| Authentication | `contexts/AuthContext.tsx` | âœ… Generic |
| Notifications | `contexts/NotificationContext.tsx` | âœ… Generic |
| Settings | `contexts/SettingsContext.tsx` | âœ… Generic |
| UI Components | `components/ui/*` | âœ… Generic |
| Layout | `components/layout/*` | âœ… Generic |
| Search Utils | `utils/searchUtils.ts` | âœ… Generic |
| Recycle Bin | `utils/recycleBin.ts` | âœ… Generic |

### ğŸ”§ CONFIGURABLE (Extract to Config)

| Module | Current State | Target State |
|--------|---------------|--------------|
| Entity Types | `Candidate`, `Job` hardcoded | `Entity` + Config |
| Pipelines | `CandidateStage` enum | Config-driven stages |
| Status Options | Hardcoded in `StatusBadge.tsx` | Config file |
| Field Definitions | 60+ fields in interface | Config-driven fields |
| Routes | Hardcoded in `App.tsx` | Config-driven routes |
| Navigation | Hardcoded in `Sidebar.tsx` | Config-driven menu |
| User Roles | `'Admin' | 'Receptionist'` | Config-driven roles |
| Labels | Hardcoded strings | i18n-ready config |

### ğŸ”Œ INDUSTRY PLUGINS (Extract as Optional)

| Feature | Location | Strategy |
|---------|----------|----------|
| CV Builder | `pages/CVBuilderPage.tsx` | Extract as plugin |
| Job Generator | `pages/JobGeneratorPage.tsx` | Extract as plugin |
| WhatsApp | `pages/WhatsAppPage.tsx` | Extract as plugin |
| Recruitment Fields | `types/index.ts` (Candidate) | Move to config |
| Appointment Types | `types/index.ts` | Move to config |

## Abstraction Examples

### Example 1: Entity Type Abstraction

**Before (Industry-Specific)**:
```typescript
interface Candidate {
  id: string;
  name: string;
  email: string;
  stage: 'Onboarding' | 'Interviewing' | 'Offer' | 'Hired';
  passportNumber?: string; // Recruitment-specific
  countryApplyingTo?: string; // Recruitment-specific
}
```

**After (Generic + Config)**:
```typescript
// Core (Generic)
interface Entity {
  id: string;
  name: string;
  email?: string;
  stage: string; // From config
  metadata: Record<string, any>; // Flexible storage
}

// Config (Industry-Specific)
const recruitmentConfig = {
  entities: {
    primary: {
      type: 'candidate',
      label: 'Candidate',
      fields: [
        { id: 'passportNumber', label: 'Passport Number', type: 'text' },
        { id: 'countryApplyingTo', label: 'Country Applying To', type: 'text' },
      ]
    }
  }
}
```

### Example 2: Pipeline Abstraction

**Before (Hardcoded)**:
```typescript
type CandidateStage = 'Onboarding' | 'Interviewing' | 'Offer' | 'Hired' | 'Rejected';
```

**After (Config-Driven)**:
```typescript
// Core (Generic)
interface PipelineStage {
  id: string;
  label: string;
  color: string;
  order: number;
}

// Config (Industry-Specific)
const recruitmentPipeline = {
  stages: [
    { id: 'onboarding', label: 'Onboarding', color: 'blue', order: 1 },
    { id: 'interviewing', label: 'Interviewing', color: 'yellow', order: 2 },
    // ...
  ]
}
```

### Example 3: Service Abstraction

**Before (Industry-Specific)**:
```typescript
// candidateService.ts
export const addCandidate = async (candidate: Candidate) => { ... }
export const updateCandidate = async (id: string, updates: Partial<Candidate>) => { ... }
```

**After (Generic)**:
```typescript
// entityService.ts
export const addEntity = async <T extends Entity>(
  entityType: string,
  entity: Omit<T, 'id'>
) => { ... }

export const updateEntity = async <T extends Entity>(
  entityType: string,
  id: string,
  updates: Partial<T>
) => { ... }
```

## Migration Priority

### Priority 1: Low Risk, High Value
1. âœ… Extract status options to config
2. âœ… Extract pipeline stages to config
3. âœ… Extract navigation routes to config
4. âœ… Extract user roles to config

**Impact**: Makes app configurable without breaking changes

### Priority 2: Medium Risk, High Value
1. ğŸ”§ Abstract entity service (Candidate â†’ Entity)
2. ğŸ”§ Create field definition system
3. ğŸ”§ Extract labels to config

**Impact**: Enables multi-industry support

### Priority 3: Lower Priority
1. ğŸ”Œ Extract CV Builder as plugin
2. ğŸ”Œ Extract Job Generator as plugin
3. ğŸ”Œ Extract WhatsApp as plugin

**Impact**: Clean separation of industry-specific features

## Configuration File Structure

```
config/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ entities.ts          # Core entity schema
â”‚   â”œâ”€â”€ pipelines.ts        # Pipeline schema
â”‚   â””â”€â”€ fields.ts            # Field definition schema
â”œâ”€â”€ industries/
â”‚   â”œâ”€â”€ recruitment.ts       # Recruitment config
â”‚   â”œâ”€â”€ healthcare.ts        # Example: Healthcare
â”‚   â””â”€â”€ realestate.ts        # Example: Real Estate
â””â”€â”€ index.ts                 # Config loader
```

## Key Principles

1. **Preserve Proven Patterns**: Don't rewrite working code
2. **Incremental Migration**: Change one layer at a time
3. **Backward Compatible**: Keep existing APIs working
4. **Configuration Over Code**: Extract hardcoded values
5. **Plugin Architecture**: Isolate industry-specific features

## Success Metrics

- âœ… Core modules have zero industry-specific code
- âœ… All labels/pipelines/fields come from config
- âœ… Can switch industries by changing config file
- âœ… Existing functionality remains intact
- âœ… Type safety maintained throughout



